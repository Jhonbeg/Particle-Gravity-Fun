<<<<<<< HEAD
// --- Configuration ---
const PARTICLE_COUNT = 8000;
const SWARM_FORCE = 0.5; // Much stronger attraction for "fast actions"
const SHAPE_FORCE = 0.2; // Snap to shape faster
const DAMPING = 0.96; // Less drag = faster movement (0.96 is very slippery)
const PINCH_THRESHOLD = 0.08;

// --- State ---
let currentShape = 'swarm'; // swarm, heart, saturn, flower, fireworks
let targetPositions = null; // Float32Array of target x,y,z for shape mode
let width = window.innerWidth;
let height = window.innerHeight;

// Gesture State
let isSwarmMode = true;
let isPinching = false;
let pinchDistance = 0;
let handCenter = new THREE.Vector3();
let indexFingerTip = new THREE.Vector3();
let lastHandTime = 0; // Track when hand was last seen

// --- Three.js Setup ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.0006);

const camera = new THREE.PerspectiveCamera(75, width / height, 1, 4000);
camera.position.z = 800;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(width, height);
renderer.setPixelRatio(window.devicePixelRatio);
// Enable auto clear false for potential trail effects if desired, but sticking to standard for clarity
document.body.appendChild(renderer.domElement);

// --- Particle System ---
const geometry = new THREE.BufferGeometry();
const pPos = new Float32Array(PARTICLE_COUNT * 3);
const pVel = new Float32Array(PARTICLE_COUNT * 3);
const pCol = new Float32Array(PARTICLE_COUNT * 3);
const originalColors = new Float32Array(PARTICLE_COUNT * 3); // Store for reverting
const shapeTargets = new Float32Array(PARTICLE_COUNT * 3);

// Initial State
for (let i = 0; i < PARTICLE_COUNT; i++) {
    const r = 1000 * Math.random();
    pPos[i * 3] = (Math.random() - 0.5) * r;
    pPos[i * 3 + 1] = (Math.random() - 0.5) * r;
    pPos[i * 3 + 2] = (Math.random() - 0.5) * r;

    // Cosmic Colors Palette: Electric Blue, Deep Purple, Star Gold, Nebula Cyan
    const choice = Math.random();
    let rC, gC, bC;
    if (choice < 0.3) { // Electric Blue
        rC = 0.1; gC = 0.5; bC = 1.0;
    } else if (choice < 0.5) { // Deep Purple
        rC = 0.6; gC = 0.0; bC = 1.0;
    } else if (choice < 0.7) { // Star Gold
        rC = 1.0; gC = 0.8; bC = 0.2;
    } else { // Nebula Cyan
        rC = 0.0; gC = 1.0; bC = 0.9;
    }

    pCol[i * 3] = rC;
    pCol[i * 3 + 1] = gC;
    pCol[i * 3 + 2] = bC;

    // Save original for smooth transition back
    originalColors[i * 3] = rC;
    originalColors[i * 3 + 1] = gC;
    originalColors[i * 3 + 2] = bC;
}

geometry.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(pCol, 3));

const material = new THREE.PointsMaterial({
    size: 2.0,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    depthTest: false,
    transparent: true,
    opacity: 0.8
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// --- 3D Reality Starfield (Background) ---
const starGeo = new THREE.BufferGeometry();
const STAR_COUNT = 15000; // High count for realism, cheap because static
const sPos = new Float32Array(STAR_COUNT * 3);
const sCol = new Float32Array(STAR_COUNT * 3);

for (let i = 0; i < STAR_COUNT; i++) {
    // Spread stars very wide for parallax
    const r = 2000 + Math.random() * 3000; // Far background
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    sPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    sPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
    sPos[i * 3 + 2] = r * Math.cos(phi);

    // Star Colors: mostly white/blue-white, some red dwarfs
    const type = Math.random();
    let c = new THREE.Color();
    if (type > 0.9) c.setHex(0xffaaaa); // Reddish
    else if (type > 0.7) c.setHex(0xaaccff); // Blueish
    else c.setHex(0xffffff); // White

    // Random brightness variation
    const brightness = 0.5 + Math.random() * 0.5;
    sCol[i * 3] = c.r * brightness;
    sCol[i * 3 + 1] = c.g * brightness;
    sCol[i * 3 + 2] = c.b * brightness;
}

starGeo.setAttribute('position', new THREE.BufferAttribute(sPos, 3));
starGeo.setAttribute('color', new THREE.BufferAttribute(sCol, 3));

const starMat = new THREE.PointsMaterial({
    size: 1.5,
    vertexColors: true,
    fog: false, // Stars pierce the fog
    transparent: true,
    opacity: 0.8
});

const starField = new THREE.Points(starGeo, starMat);
// IMPORTANT: Frustum culling off ensures they don't flicker if they are "too far" or big bounds
starField.frustumCulled = false;
scene.add(starField);

// --- Shape Generators ---
function generateShape(type) {
    const arr = new Float32Array(PARTICLE_COUNT * 3);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let x = 0, y = 0, z = 0;

        if (type === 'heart') {
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI; // For Z volume
            const t = phi;
            let hx = 16 * Math.pow(Math.sin(t), 3);
            let hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            let scale = 15;
            x = hx * scale;
            y = hy * scale;
            z = (Math.random() - 0.5) * 100;
        }
        else if (type === 'saturn') {
            const isRing = Math.random() > 0.4;
            if (isRing) {
                const angle = Math.random() * Math.PI * 2;
                const r = 250 + Math.random() * 150;
                x = Math.cos(angle) * r;
                z = Math.sin(angle) * r;
                y = (Math.random() - 0.5) * 10;
            } else {
                const r = 180;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }
            const tilt = 0.4;
            const tx = x;
            x = tx * Math.cos(tilt) - y * Math.sin(tilt);
            y = tx * Math.sin(tilt) + y * Math.cos(tilt);
        }
        else if (type === 'flower') {
            const k = 4;
            const theta = Math.random() * Math.PI * 2;
            const r_curve = Math.cos(k * theta);
            const r = 300 * Math.abs(r_curve) + 50;
            x = r * Math.cos(theta);
            y = r * Math.sin(theta);
            z = -r_curve * 100 + (Math.random() - 0.5) * 50;
        }
        else if (type === 'fireworks') {
            const r = 300 + Math.random() * 300;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
        }

        arr[i * 3] = x;
        arr[i * 3 + 1] = y;
        arr[i * 3 + 2] = z;
    }
    return arr;
}

// Global UI function
window.setShape = (shape) => {
    currentShape = shape;
    isSwarmMode = (shape === 'swarm');

    if (!isSwarmMode) {
        const targets = generateShape(shape);
        for (let i = 0; i < targets.length; i++) {
            shapeTargets[i] = targets[i];
        }
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        const btn = Array.from(document.querySelectorAll('button')).find(b => b.innerText.toLowerCase().includes(shape));
        if (btn) btn.classList.add('active');
    } else {
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.querySelector('button').classList.add('active');
    }

    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        pVel[i] *= 0.1;
    }
}

window.toggleFullscreen = () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}


// --- MediaPipe Hands Logic ---
const videoElement = document.getElementsByClassName('input_video')[0];

function onResults(results) {
    document.getElementById('loading').style.display = 'none';

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        lastHandTime = Date.now();
        const landmarks = results.multiHandLandmarks[0];

        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];
        const wrist = landmarks[0];

        // --- POLISH: Geometric Sanity Check ---
        const handSize = Math.sqrt(
            Math.pow(indexTip.x - wrist.x, 2) +
            Math.pow(indexTip.y - wrist.y, 2)
        );

        // Filter out tiny false positives or massive glitches
        if (handSize < 0.05 || handSize > 0.8) {
            isPinching = false;
            if (isSwarmMode) indexFingerTip.lerp(new THREE.Vector3(0, 0, 0), 0.05);
            return;
        }

        // 1. Calculate World Position for Index Tip
        const vFOV = camera.fov * Math.PI / 180;
        const visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
        const visibleWidth = visibleHeight * camera.aspect;

        const x = (1 - indexTip.x - 0.5) * visibleWidth;
        const y = -(indexTip.y - 0.5) * visibleHeight;

        indexFingerTip.lerp(new THREE.Vector3(x, y, 0), 0.85);

        // 2. Pinch Detection
        const dx = indexTip.x - thumbTip.x;
        const dy = indexTip.y - thumbTip.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        isPinching = dist < PINCH_THRESHOLD;
        pinchDistance = dist;

        handCenter.copy(indexFingerTip);

    } else {
        isPinching = false;
    }
}

const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => await hands.send({ image: videoElement }),
    width: 640, height: 480
});
cameraUtils.start();


// --- Animation Loop ---
let time = 0;

function animate() {
    requestAnimationFrame(animate);
    time += 0.01;

    material.color.setHex(0xffffff);

    const positions = particles.geometry.attributes.position.array;
    const colors = particles.geometry.attributes.color.array;

    // Auto-center if hand is lost
    if (isSwarmMode && Date.now() - lastHandTime > 1000) {
        indexFingerTip.lerp(new THREE.Vector3(0, 0, 0), 0.05);
        isPinching = false;
    }

    // Color Logic: Smooth Transition
    const timeScale = time * 3.0;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ix = i * 3;

        // Determine Target Color
        let tr, tg, tb;

        if (isPinching) {
            // PINCH: Red/Yellow Fire
            tr = 1.0;
            tg = Math.abs(Math.sin(timeScale + i * 0.005));
            tb = 0.0;
        } else {
            // NO PINCH: Revert to Original Cosmic Palette
            tr = originalColors[ix];
            tg = originalColors[ix + 1];
            tb = originalColors[ix + 2];
        }

        // Smooth Lerp (Polish)
        colors[ix] += (tr - colors[ix]) * 0.1;
        colors[ix + 1] += (tg - colors[ix + 1]) * 0.1;
        colors[ix + 2] += (tb - colors[ix + 2]) * 0.1;
    }

    // Physics Logic
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ix = i * 3;
        const iy = i * 3 + 1;
        const iz = i * 3 + 2;

        let px = positions[ix];
        let py = positions[iy];
        let pz = positions[iz];

        let vx = pVel[ix];
        let vy = pVel[iy];
        let vz = pVel[iz];

        if (isSwarmMode) {
            // --- SWARM MODE ---
            const dx = indexFingerTip.x - px;
            const dy = indexFingerTip.y - py;
            const dz = indexFingerTip.z - pz;

            const distSq = dx * dx + dy * dy + dz * dz + 100;
            const pull = 2000 / distSq;

            vx += dx * pull * SWARM_FORCE;
            vy += dy * pull * SWARM_FORCE;
            vz += dz * pull * SWARM_FORCE;

            // Anti-Clumping
            const distToFinger = Math.sqrt(dx * dx + dy * dy + dz * dz) + 1;
            if (distToFinger < 150) {
                const push = (150 - distToFinger) * 0.05;
                vx -= (dx / distToFinger) * push;
                vy -= (dy / distToFinger) * push;
                vz -= (dz / distToFinger) * push;
            }

            vx += dx * 0.0002;
            vy += dy * 0.0002;
            vz += dz * 0.0002;

            const dist = Math.sqrt(dx * dx + dy * dy + 100);
            vx += (dy / dist) * 0.5;
            vy -= (dx / dist) * 0.5;

            // Boundary Return
            const distFromCenterSq = px * px + py * py + pz * pz;
            if (distFromCenterSq > 500000) {
                vx -= px * 0.0001;
                vy -= py * 0.0001;
                vz -= pz * 0.0001;
            }
        } else {
            // --- SHAPE MODE ---
            const tx = shapeTargets[ix];
            const ty = shapeTargets[iy];
            const tz = shapeTargets[iz];

            let expansion = 1.0;

            const dx = (tx * expansion) - px;
            const dy = (ty * expansion) - py;
            const dz = (tz * expansion) - pz;

            vx += dx * SHAPE_FORCE;
            vy += dy * SHAPE_FORCE;
            vz += dz * SHAPE_FORCE;

            const fdx = indexFingerTip.x - px;
            const fdy = indexFingerTip.y - py;
            const fdist = Math.sqrt(fdx * fdx + fdy * fdy);
            if (fdist < 100) {
                vx -= fdx * 0.1;
                vy -= fdy * 0.1;
            }
        }

        vx += (Math.random() - 0.5) * 0.1;
        vy += (Math.random() - 0.5) * 0.1;
        vz += (Math.random() - 0.5) * 0.1;

        vx *= DAMPING;
        vy *= DAMPING;
        vz *= DAMPING;

        positions[ix] += vx;
        positions[iy] += vy;
        positions[iz] += vz;

        pVel[ix] = vx;
        pVel[iy] = vy;
        pVel[iz] = vz;
    }

    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.color.needsUpdate = true;

    scene.rotation.y = Math.sin(time * 0.1) * 0.1;

    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
});

animate();
=======
(async () => {
    const _0x1a = console.log; console.log = () => { };
    const _0x = document, _0xc = _0x.createElement('canvas'); _0x.body.appendChild(_0xc);
    const _0xe = window, _0xf = Math.random, _0xs = Math.sin;
    const _W = window.innerWidth, _H = window.innerHeight;
    const _GL = _0xc.getContext('webgl');
    setInterval(() => { const _d = new Date(); debugger; if (new Date() - _d > 100) _0x.body.innerHTML = 'nice try'; }, 1000);
    const _S = new THREE.Scene(); _S.fog = new THREE.FogExp2(0, 0.0006);
    const _C = new THREE.PerspectiveCamera(75, _W / _H, 1, 4000); _C.position.z = 800;
    const _R = new THREE.WebGLRenderer({ antialias: !0, alpha: !0 });
    _R.setSize(_W, _H); _R.setPixelRatio(_0xe.devicePixelRatio);
    _0x.body.appendChild(_R.domElement);
    const _req = await fetch('engine.wasm');
    const _buf = await _req.arrayBuffer();
    const _mod = await WebAssembly.instantiate(_buf, { env: {} });
    const _core = _mod.instance.exports;
    const _mem = new Float32Array(_core.memory.buffer);
    const _ptr = _core.get_memory_offset() / 4;
    _core.init();
    const _geo = new THREE.BufferGeometry();
    const _cnt = 8000;
    const _pos = new Float32Array(_cnt * 3);
    const _col = new Float32Array(_cnt * 3);
    for (let i = 0; i < _cnt; i++) {
        const b = _ptr + i * 12;
        _pos[i * 3] = _mem[b]; _pos[i * 3 + 1] = _mem[b + 1]; _pos[i * 3 + 2] = _mem[b + 2];
        _col[i * 3] = _mem[b + 9]; _col[i * 3 + 1] = _mem[b + 10]; _col[i * 3 + 2] = _mem[b + 11];
    }
    _geo.setAttribute('position', new THREE.BufferAttribute(_pos, 3));
    _geo.setAttribute('color', new THREE.BufferAttribute(_col, 3));
    const _mat = new THREE.PointsMaterial({ size: 2.0, vertexColors: !0, blending: THREE.AdditiveBlending, depthTest: !1, transparent: !0, opacity: 0.8 });
    const _sys = new THREE.Points(_geo, _mat);
    _S.add(_sys);
    const _stG = new THREE.BufferGeometry(); const _stC = 15000;
    const _stP = new Float32Array(_stC * 3), _stKl = new Float32Array(_stC * 3);
    for (let i = 0; i < _stC; i++) {
        const r = 2000 + _0xf() * 3000, th = _0xf() * Math.PI * 2, ph = Math.acos(2 * _0xf() - 1);
        _stP[i * 3] = r * Math.sin(ph) * Math.cos(th); _stP[i * 3 + 1] = r * Math.sin(ph) * Math.sin(th); _stP[i * 3 + 2] = r * Math.cos(ph);
        const br = 0.5 + _0xf() * 0.5; _stKl[i * 3] = br; _stKl[i * 3 + 1] = br; _stKl[i * 3 + 2] = br + (_0xf() > 0.9 ? 0.2 : 0);
    }
    _stG.setAttribute('position', new THREE.BufferAttribute(_stP, 3));
    _stG.setAttribute('color', new THREE.BufferAttribute(_stKl, 3));
    const _stM = new THREE.PointsMaterial({ size: 1.5, vertexColors: !0, fog: !1, transparent: !0, opacity: 0.8 });
    _S.add(new THREE.Points(_stG, _stM));
    let _mx = 0, _my = 0, _mz = 0, _pinch = 0, _tm = 0;
    let _mode = 0;
    _0xe.setShape = (m) => {
        const map = { swarm: 0, heart: 1, saturn: 2, flower: 3, fireworks: 4 };
        const id = map[m] || 0; _mode = id;
        _core.set_shape(id);
        _0x.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        [..._0x.querySelectorAll('button')].find(b => b.innerText.toLowerCase().includes(m))?.classList.add('active');
    };
    _0xe.toggleFullscreen = () => { _0x.fullscreenElement ? _0x.exitFullscreen() : _0x.documentElement.requestFullscreen() };
    const _v = _0x.getElementsByClassName('input_video')[0];
    const _h = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    _h.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    _h.onResults(r => {
        _0x.getElementById('loading').style.display = 'none';
        if (r.multiHandLandmarks?.length) {
            const l = r.multiHandLandmarks[0];
            const it = l[8], tt = l[4];
            const vFOV = _C.fov * Math.PI / 180;
            const vH = 2 * Math.tan(vFOV / 2) * _C.position.z;
            const vW = vH * _C.aspect;
            const tx = (1 - it.x - 0.5) * vW, ty = -(it.y - 0.5) * vH;
            _mx += (tx - _mx) * 0.85; _my += (ty - _my) * 0.85;
            const dx = it.x - tt.x, dy = it.y - tt.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            _pinch = d < 0.08 ? 1.0 : 0.0;
        } else { _pinch = 0; }
    });
    const _cam = new Camera(_v, { onFrame: async () => await _h.send({ image: _v }), width: 640, height: 480 });
    _cam.start();
    function _loop() {
        requestAnimationFrame(_loop);
        _tm += 0.01;
        _core.update(0.016, _mode, _mx, _my, _mz, _pinch, _tm);
        for (let i = 0; i < _cnt; i++) {
            const b = _ptr + i * 12;
            _pos[i * 3] = _mem[b]; _pos[i * 3 + 1] = _mem[b + 1]; _pos[i * 3 + 2] = _mem[b + 2];
            _col[i * 3] = _mem[b + 9]; _col[i * 3 + 1] = _mem[b + 10]; _col[i * 3 + 2] = _mem[b + 11];
        }
        _geo.attributes.position.needsUpdate = !0;
        _geo.attributes.color.needsUpdate = !0;
        _S.rotation.y = Math.sin(_tm * 0.1) * 0.1;
        _R.render(_S, _C);
    }
    _loop();
    _0xe.addEventListener('resize', () => {
        const w = _0xe.innerWidth, h = _0xe.innerHeight;
        _C.aspect = w / h; _C.updateProjectionMatrix(); _R.setSize(w, h);
    });
})();
>>>>>>> eb5787f571338c55ed4f84dd670d7094eb2286ad
