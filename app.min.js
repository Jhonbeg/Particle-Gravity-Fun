(async () => {
    const _0x1a = console.log; console.log = () => { };
    const _0x = document, _0xc = _0x.createElement('canvas'); _0x.body.appendChild(_0xc);
    const _0xe = window, _0xf = Math.random, _0xs = Math.sin;
    const _W = window.innerWidth, _H = window.innerHeight;
    const _GL = _0xc.getContext('webgl');
    setInterval(() => { const _d = new Date(); debugger; if (new Date() - _d > 100) _0x.body.innerHTML = 'nice try'; }, 1000);
    const _S = new THREE.Scene(); _S.fog = new THREE.FogExp2(0, 0.0006);
    const _C = new THREE.PerspectiveCamera(75, _W / _H, 1, 4000); _C.position.z = 800;
    const _R = new THREE.WebGLRenderer({ antialias: !0, alpha: !0 });
    _R.setSize(_W, _H); _R.setPixelRatio(_0xe.devicePixelRatio);
    _0x.body.appendChild(_R.domElement);
    const _req = await fetch('engine.wasm');
    const _buf = await _req.arrayBuffer();
    const _mod = await WebAssembly.instantiate(_buf, { env: {} });
    const _core = _mod.instance.exports;
    const _mem = new Float32Array(_core.memory.buffer);
    const _ptr = _core.get_memory_offset() / 4;
    _core.init();
    const _geo = new THREE.BufferGeometry();
    const _cnt = 8000;
    const _pos = new Float32Array(_cnt * 3);
    const _col = new Float32Array(_cnt * 3);
    for (let i = 0; i < _cnt; i++) {
        const b = _ptr + i * 12;
        _pos[i * 3] = _mem[b]; _pos[i * 3 + 1] = _mem[b + 1]; _pos[i * 3 + 2] = _mem[b + 2];
        _col[i * 3] = _mem[b + 9]; _col[i * 3 + 1] = _mem[b + 10]; _col[i * 3 + 2] = _mem[b + 11];
    }
    _geo.setAttribute('position', new THREE.BufferAttribute(_pos, 3));
    _geo.setAttribute('color', new THREE.BufferAttribute(_col, 3));
    const _mat = new THREE.PointsMaterial({ size: 2.0, vertexColors: !0, blending: THREE.AdditiveBlending, depthTest: !1, transparent: !0, opacity: 0.8 });
    const _sys = new THREE.Points(_geo, _mat);
    _S.add(_sys);
    const _stG = new THREE.BufferGeometry(); const _stC = 15000;
    const _stP = new Float32Array(_stC * 3), _stKl = new Float32Array(_stC * 3);
    for (let i = 0; i < _stC; i++) {
        const r = 2000 + _0xf() * 3000, th = _0xf() * Math.PI * 2, ph = Math.acos(2 * _0xf() - 1);
        _stP[i * 3] = r * Math.sin(ph) * Math.cos(th); _stP[i * 3 + 1] = r * Math.sin(ph) * Math.sin(th); _stP[i * 3 + 2] = r * Math.cos(ph);
        const br = 0.5 + _0xf() * 0.5; _stKl[i * 3] = br; _stKl[i * 3 + 1] = br; _stKl[i * 3 + 2] = br + (_0xf() > 0.9 ? 0.2 : 0);
    }
    _stG.setAttribute('position', new THREE.BufferAttribute(_stP, 3));
    _stG.setAttribute('color', new THREE.BufferAttribute(_stKl, 3));
    const _stM = new THREE.PointsMaterial({ size: 1.5, vertexColors: !0, fog: !1, transparent: !0, opacity: 0.8 });
    _S.add(new THREE.Points(_stG, _stM));
    let _mx = 0, _my = 0, _mz = 0, _pinch = 0, _tm = 0;
    let _mode = 0;
    _0xe.setShape = (m) => {
        const map = { swarm: 0, heart: 1, saturn: 2, flower: 3, fireworks: 4 };
        const id = map[m] || 0; _mode = id;
        _core.set_shape(id);
        _0x.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        [..._0x.querySelectorAll('button')].find(b => b.innerText.toLowerCase().includes(m))?.classList.add('active');
    };
    _0xe.toggleFullscreen = () => { _0x.fullscreenElement ? _0x.exitFullscreen() : _0x.documentElement.requestFullscreen() };
    const _v = _0x.getElementsByClassName('input_video')[0];
    const _h = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    _h.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    _h.onResults(r => {
        _0x.getElementById('loading').style.display = 'none';
        if (r.multiHandLandmarks?.length) {
            const l = r.multiHandLandmarks[0];
            const it = l[8], tt = l[4];
            const vFOV = _C.fov * Math.PI / 180;
            const vH = 2 * Math.tan(vFOV / 2) * _C.position.z;
            const vW = vH * _C.aspect;
            const tx = (1 - it.x - 0.5) * vW, ty = -(it.y - 0.5) * vH;
            _mx += (tx - _mx) * 0.85; _my += (ty - _my) * 0.85;
            const dx = it.x - tt.x, dy = it.y - tt.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            _pinch = d < 0.08 ? 1.0 : 0.0;
        } else { _pinch = 0; }
    });
    const _cam = new Camera(_v, { onFrame: async () => await _h.send({ image: _v }), width: 640, height: 480 });
    _cam.start();
    function _loop() {
        requestAnimationFrame(_loop);
        _tm += 0.01;
        _core.update(0.016, _mode, _mx, _my, _mz, _pinch, _tm);
        for (let i = 0; i < _cnt; i++) {
            const b = _ptr + i * 12;
            _pos[i * 3] = _mem[b]; _pos[i * 3 + 1] = _mem[b + 1]; _pos[i * 3 + 2] = _mem[b + 2];
            _col[i * 3] = _mem[b + 9]; _col[i * 3 + 1] = _mem[b + 10]; _col[i * 3 + 2] = _mem[b + 11];
        }
        _geo.attributes.position.needsUpdate = !0;
        _geo.attributes.color.needsUpdate = !0;
        _S.rotation.y = Math.sin(_tm * 0.1) * 0.1;
        _R.render(_S, _C);
    }
    _loop();
    _0xe.addEventListener('resize', () => {
        const w = _0xe.innerWidth, h = _0xe.innerHeight;
        _C.aspect = w / h; _C.updateProjectionMatrix(); _R.setSize(w, h);
    });
})();
